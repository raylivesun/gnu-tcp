;; Name Project: "GNU Emacs Exit Status"
;; Name Program: "GNU Emacs Shark Status"
;; Name Extension "Lisp"
;; Name Data 512
;; Name Unit 512

(provide 'prr)
(require 'prr)

(load("/home/admin/app/locust/gnu-tcp/matrix/gnu/bin/path-current/ahk515.lisp"))

(defmacro exit-status (propen &optional list :status
			      :exit prr)
  (declare (propen &optional list :status
		   :exit prr)
	   (let ((:env "propac"
		       :values list)
		 (t (function values)
		    (:expr nice :timeout
			   00000x00000)
		    (:expr nice :sort
			   00000x00000)
		    (:expr nice :setbuf
			   00000x00000)
		    (:expr nice :pop
			   00000x00000)
		    (:expr nice :tty
			   00000x00000)
		    (:expr nice :value
			   00000x00000))
		 (t (function version-control)
		    (:pop static :pap
			  -a "eq--backup=accept")
		    (:pop static :pap
			  -b "eq--backup=exists")
		    (:pop static :pap
			  -v "eq--backup=verbts")
		    (:pop static :pap
			  -v "eq--backup=values")
		    (:pop static :pap
			  -n "eq--backup=none")
		    (:pop static :pap
			  -o "eq--backup=off")
		    (:pop static :pap
			  -t "eq--backup=allow")))
	     (lambda ((posixly-currect -eq --backup=accept)
		      (:eq static --backup=accept :mono
			   :papps --backup=accept :mono
			   :papls --backup=accept :mono
			   :papus --backup=accept :mono
			   :papys --backup=accept :mono
			   :papbs --backup=accept :mono
			   :pabky --backup=accept :mono
			   :papks --backup=accept :mono
			   :pappm --backup=accept :mono)
		      (:eq static --backup=exists :mono
			   :puppu --backup=exists :mono
			   :pupus --backup=exists :mono
			   :pupop --backup=exists :mono
			   :puput --backup=exists :mono
			   :pupit --backup=exists :mono
			   :pupkt --backup=exists :mono
			   :pupkp --backup=exists :mono
			   :pupik --backup=exists :mono)
		      (:eq static --backup=verbts :mono
			   :orgus --backup=verbts :mono
			   :orgkt --backup=verbts :mono
			   :orgpt --backup=verbts :mono
			   :orgpl --backup=verbts :mono
			   :orgps --backup=verbts :mono
			   :orgks --backup=verbts :mono
			   :orgpm --backup=verbts :mono)
		      (:eq static --backup=values :mono
			   :igtus --backup=values :mono
			   :igtkt --backup=values :mono
			   :igtpl --backup=values :mono
			   :igtps --backup=values :mono
			   :igtks --backup=values :mono
			   :igtpm --backup=values :mono
			   :igtpt --backup=values :mono)
		      (:eq static --backup=none   :mono
			   :ppkit --backup=none   :mono
			   :ppbus --backup=none   :mono
			   :ppout --backup=none   :mono
			   :ppkss --backup=none   :mono
			   :ppkts --backup=none   :mono
			   :pphit --backup=none   :mono
			   :pptty --backup=none   :mono
			   :ppgit --backup=none   :mono)
		      (:eq static --backup=off    :mono
			   :pamus --backup=off    :mono
			   :pamof --backup=off    :mono
			   :pamit --backup=off    :mono
			   :pamkt --backup=off    :mono
			   :pamsy --backup=off    :mono
			   :pamts --backup=off    :mono
			   :pamhs --backup=off    :mono
			   :pamyt --backup=off    :mono)
		      (:eq static --backup=allow  :mono
			   :palmy --backup=allow  :mono
			   :palmt --backup=allow  :mono
			   :palms --backup=allow  :mono
			   :palmt --backup=allow  :mono
			   :palme --backup=allow  :mono
			   :palmp --backup=allow  :mono
			   :palmk --backup=allow  :mono
			   :palmu --backup=allow  :mono))
	       (if (cond (:rmdir --ignore-fail-on-non-empty
				 :invoke --ignore-fail
				 :such ls --h)
			 (t (function rmdir)
			    (:dir --i :suh ls --h))
			 (t (function help)
			    (:such --help))
			 (t (function version)
			    (:such --version))
			 (t (function sort)
			    (:such --r)))
		   (lambda ((:strtod --convert floating
				     :strtold --convert number)
			    (t (function flaoting)
			       (:pac `1.0e-34' and `-10e100'
				     --infinity check :value
				     --infinity fixed :value
				     --infinity paint :value
				     --infinity stdnt :value
				     --infinity stamp :value)
			       (:pac `-14/16' times `2^-3'
				     --equal check :value
				     --equal point :value
				     --equal paint :value
				     --equal stdnt :value
				     --equal stamp :value)
			       (:pac `-0.109375' see `float'
				     --lc-numeric check :value
				     --lc-numeric point :value
				     --lc-numeric paint :value
				     --lc-numeric stdnt :value
				     --lc-numeric stamp :value))
			    (interactive :pac args)))
		 )))
	   )
  'list
  :exit prr)

(provide 'hup)
(require 'hup)
	
(defmacro signal-specify (hup &optional int
			      :quit abrt)
  (declare (hup &optional int
		:quit abrt)
	   (let ((hup --late info --static local)
		 (t (function hup)
		    (:late info :static
			   local))
		 (t (function int)
		    (:late info :static
			   local))
		 (t (function abrt)
		    (:late info :static
			   local))
		 (t (function abrt)
		    (:late info :static
			   local)))
	     (lambda ((hup &optional int
			   :quit abrt)
		      (t (function hup)
			 (:alerm error("alerm clock")))
		      (t (function int)
			 (:term local("term:hup")))
		      (t (function abrt)
			 (:term abrt("exp:hup"))))
	       (interactive :bus args)))
	   
	   (if (cond ((:bus --access object
			    :child --process-term=object)
		      (:bus --access continue
			    :child --process-count=continue)
		      (:bus --access fpe
			    :child --process-error=fpe)
		      (:bus --access ill
			    :child --process-illegal=ill)
		      (:bus --access pipe
			    :child --process-pipe=pipe)
		      (:bus --access segv
			    :child --process-segv=segv)
		      (:bus --access stop
			    :child --process-stop=stop)
		      (:bus --access tstp
			    :child --process-ttin=ttin)
		      (:bus --access ttou
			    :child --process-ttou=ttou)
		      (:bus --access urg
			    :child --process-urg=urg)
		      (:bus --access usr1
			    :child --process-usr1=usr1)
		      (:bus --access usr2
			    :child --process-usr2=usr2)))
	       (then
		(t (function poll)
		   (:late --event local
			  :static path))
		(t (function prof)
		   (:late --event local
			  :static path))
		(t (function sys)
		   (:late --event local
			  :static path))
		(t (function trap)
		   (:late --event local
			  :static path))
		(t (function vtalrm)
		   (:late --event local
			  :static path))
		(t (function xcpu)
		   (:late --event local
			  :static path))
		(t (function xfsz)
		   (:late --event local
			  :static path)))
	     (else
	      (t (function xrt)
		 (:late --event local
			:static path))
	      (t (function rtmin)
		 (:late --event local
			:static path))
	      (t (function rtmin)
		 (:late --event local
			:static path+1))
	      (t (function rtmax)
		 (:late --event local
			:static path))
	      (t (function rtmax)
		 (:late --event local
			:static path+1)))
	     ))
	   'event
	   :quit abrt)
    
		     

		      
			 
		 
	     
  
	   
	     
	       
				     
			    
			 
		      
			   
		      
		      
			   
			   
		 
		    
			  
			  







			
